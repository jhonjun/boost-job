[/
          Copyright Oliver Kowalke 2015.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:job_mgmt Job management]

[heading Synopsis]

    #include <boost/job/all.hpp>

    namespace boost {
    namespace jobs {

    class scheduler;

    namespace this_worker {

    template< typename Fn, typename ... Args >
    fibers::future< typename std::result_of< Fn( Args ... ) >::type >
    submit( Fn && fn, Args && ... args);

    }}}

__boost_job__ provides function __cpu_topology__ to inspect which logical CPUs
are online. The returned structure contains the ID of logical CPU [footnote On
Windows] are online, the ID of the NUMA node to which the logical CPU belongs
and with which other logical CPUs L1/L2/L3 cache is shared [footnore not all
platforms supported].
This information is used internally to pin worker threads to logical CPUs and
which logical CPU is aprobriate for a job (memory latency).

[heading Launching]

[heading Exceptions]

[#class_scheduler]
[section:scheduler Class `scheduler`]

    #include <boost/job/scheduler.hpp>
    
    class scheduler {
    public:
        scheduler();
    
        template< typename FiberPool, typename StackAllocator >
        scheduler( std::vector< topo_t > const& topology, FiberPool && pool, StackAllocator salloc);
    
        template< typename FiberPool >
        scheduler( std::vector< topo_t > const& topology, FiberPool && pool);
    
        scheduler( std::vector< topo_t > const& topology);
    
        ~scheduler();
    
        scheduler( scheduler const&) = delete;
    
        scheduler & operator=( scheduler const&) = delete;
    
        template< typename Allocator, typename Fn, typename ... Args >
        std::future< typename std::result_of< Fn( Args ... ) >::type >
        submit_preempt( std::allocator_arg_t, Allocator alloc, uint32_t cpuid, Fn && fn, Args && ... args);
    
        template< typename Fn, typename ... Args >
        std::future< typename std::result_of< Fn( Args ... ) >::type >
        submit_preempt( uint32_t cpuid, Fn && fn, Args && ... args);
    
        template< typename Allocator, typename Fn, typename ... Args >
        fibers::future< typename std::result_of< Fn&&( Args ... ) >::type >
        submit_coop( std::allocator_arg_t, Allocator alloc, uint32_t cpuid, Fn && fn, Args && ... args);
    
        template< typename Fn, typename ... Args >
        fibers::future< typename std::result_of< Fn( Args ... ) >::type >
        submit_coop( uint32_t cpuid, Fn && fn, Args && ... args);
    
        void shutdown();
    };


[endsect] [/ section Class scheduler]

[section:this_worker Namespace this_worker]

    namespace boost {
    namespace jobs {
    namespace this_worker {

    topo_t topology() noexcept;

    }}}

[ns_function_heading this_worker..topology()]

    #include <boost/job/operations.hpp>

    topo_t topology() noexcept;

[variablelist
[[Returns:] []]
[[Throws:] [Nothing.]]
]

[endsect] [/ section Namespace this_worker]

[section:this_worker Namespace this_worker]

    namespace boost {
    namespace jobs {
    namespace this_worker {

    template< typename Fn, typename ... Args >
    fibers::future< typename std::result_of< Fn( Args ... ) >::type >
    submit( Fn && fn, Args && ... args);

    }}}

[ns_function_heading this_worker..submit()]

    #include <boost/job/operations.hpp>

    template< typename Fn, typename ... Args >
    fibers::future< typename std::result_of< Fn( Args ... ) >::type >
    submit( Fn && fn, Args && ... args);

[variablelist
[[Returns:] []]
[[Throws:] [Nothing.]]
]

[endsect] [/ section Namespace this_worker]

[endsect]
